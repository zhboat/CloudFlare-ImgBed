name: Sync R2 Images to CNB Mirror
on:
  schedule:
    - cron: '0 */6 * * *'  # 每6小时同步一次
  workflow_dispatch:       # 支持手动触发

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Install rclone & ffmpeg
        run: |
          curl https://rclone.org/install.sh | sudo bash
          sudo apt-get update -qq && sudo apt-get install -y -qq ffmpeg

      - name: Configure rclone for R2
        run: |
          mkdir -p ~/.config/rclone
          cat > ~/.config/rclone/rclone.conf << EOF
          [r2]
          type = s3
          provider = Cloudflare
          access_key_id = ${{ secrets.R2_ACCESS_KEY }}
          secret_access_key = ${{ secrets.R2_SECRET_KEY }}
          endpoint = https://${{ secrets.CF_ACCOUNT_ID }}.r2.cloudflarestorage.com
          acl = private

          [s3cdn]
          type = s3
          provider = Other
          env_auth = false
          access_key_id = ${{ secrets.S3_ACCESS_KEY }}
          secret_access_key = ${{ secrets.S3_SECRET_KEY }}
          end = https://s3.bitiful.net
          no_check_bucket = true
          EOF

      - name: Clone CNB repo
        run: git clone "https://${{ secrets.CNBUSER }}:${{ secrets.CNBTOKEN }}@cnb.cool/deepalhome/imgbed.git" mirror

      - name: Sync from R2
        run: rclone sync r2:img-r2 mirror/ --exclude ".git/**" --exclude "docs/**"

      - name: Sync dynamic wallpaper videos to S3
        run: |
          rclone sync mirror/pic/动态壁纸/ "s3cdn:${{ secrets.S3_BUCKET }}/pic/动态壁纸/" --include "*.mp4" --include "*.m4v" --include "*.mov"

      - name: Generate wallpaper API
        env:
          S3_BASE_URL: "https://${{ secrets.S3_BUCKET }}.s3.bitiful.net"
        run: |
          cat > /tmp/gen_api.py << 'PYEOF'
          import json, os, subprocess, sys, urllib.parse
          from pathlib import Path

          BASE_RAW_URL = "https://cnb.cool/deepalhome/imgbed/-/git/raw/main"
          S3_BASE_URL = os.environ.get("S3_BASE_URL", "")
          VIDEO_EXT = {'.mp4', '.m4v', '.mov'}
          IMAGE_EXT = {'.jpg', '.jpeg', '.png', '.webp', '.gif', '.bmp', '.heic', '.heif'}
          ALL_EXT = VIDEO_EXT | IMAGE_EXT
          CACHE_FILE = "docs/api/v1/.metadata-cache.json"
          THUMB_DIR = "docs/thumbs"

          CATEGORIES = [
              {"dir": "pic/动态壁纸",  "output": "docs/api/v1/dynamic.json",   "ext": ALL_EXT},
              {"dir": "pic/悬浮球",    "output": "docs/api/v1/floatball.json",  "ext": ALL_EXT},
              {"dir": "pic/静态壁纸",  "output": "docs/api/v1/static.json",     "ext": IMAGE_EXT},
          ]

          def load_cache(root):
              p = os.path.join(root, CACHE_FILE)
              if os.path.isfile(p):
                  try:
                      with open(p, "r", encoding="utf-8") as f:
                          return json.load(f)
                  except Exception:
                      pass
              return {}

          def save_cache(root, cache):
              p = os.path.join(root, CACHE_FILE)
              os.makedirs(os.path.dirname(p), exist_ok=True)
              with open(p, "w", encoding="utf-8") as f:
                  json.dump(cache, f, ensure_ascii=False, indent=2)

          def probe_ffmpeg(filepath):
              w, h = 0, 0
              try:
                  r = subprocess.run(
                      ["ffprobe", "-v", "quiet", "-print_format", "json", "-show_streams", filepath],
                      capture_output=True, text=True, timeout=30)
                  if r.returncode == 0:
                      for s in json.loads(r.stdout).get("streams", []):
                          if s.get("codec_type") in ("video", "image"):
                              w, h = int(s.get("width", 0)), int(s.get("height", 0))
                              break
              except Exception:
                  pass
              return w, h

          def generate_thumb(root, filepath, rel):
              thumb_rel = THUMB_DIR + "/" + Path(rel).with_suffix(".jpg").as_posix()
              thumb_path = os.path.join(root, thumb_rel)
              os.makedirs(os.path.dirname(thumb_path), exist_ok=True)
              try:
                  subprocess.run(
                      ["ffmpeg", "-y", "-i", filepath, "-vframes", "1",
                       "-q:v", "2", "-vf", "scale='min(720,iw)':-2", thumb_path],
                      capture_output=True, timeout=60)
                  if os.path.isfile(thumb_path) and os.path.getsize(thumb_path) > 0:
                      print(f"    [thumb] {thumb_rel}")
                      return thumb_rel
              except Exception:
                  pass
              return None

          def probe(root, filepath, rel, ext, cache):
              size = os.path.getsize(filepath)
              cached = cache.get(rel)
              is_video = ext in VIDEO_EXT
              if cached and cached.get("size") == size:
                  thumb_rel = cached.get("thumb")
                  if is_video and thumb_rel:
                      thumb_path = os.path.join(root, thumb_rel)
                      if os.path.isfile(thumb_path):
                          return cached["width"], cached["height"], size, thumb_rel
                  elif not is_video:
                      return cached["width"], cached["height"], size, None
              print(f"    [probe] {rel}")
              w, h = probe_ffmpeg(filepath)
              entry = {"size": size, "width": w, "height": h}
              thumb_rel = None
              if is_video:
                  thumb_rel = generate_thumb(root, filepath, rel)
                  if thumb_rel:
                      entry["thumb"] = thumb_rel
              cache[rel] = entry
              return w, h, size, thumb_rel

          def display_name(filename):
              stem = Path(filename).stem
              parts = stem.split("_", 1)
              if len(parts) == 2 and not parts[1].isdigit():
                  return parts[1]
              return stem

          def build_url(rel):
              return BASE_RAW_URL + "/" + "/".join(urllib.parse.quote(p) for p in rel.split("/"))

          def build_s3_url(rel):
              if not S3_BASE_URL:
                  return None
              return S3_BASE_URL + "/" + "/".join(urllib.parse.quote(p) for p in rel.split("/"))

          def generate(root, cat, cache):
              d = os.path.join(root, cat["dir"])
              if not os.path.isdir(d):
                  print(f"  skip (not found): {d}")
                  return set()
              items = []
              seen = set()
              for f in sorted(os.listdir(d), reverse=True):
                  fp = os.path.join(d, f)
                  if not os.path.isfile(fp):
                      continue
                  ext = Path(f).suffix.lower()
                  if ext not in cat["ext"]:
                      continue
                  rel = cat["dir"] + "/" + f
                  seen.add(rel)
                  print(f"  {f}")
                  w, h, sz, thumb_rel = probe(root, fp, rel, ext, cache)
                  url = build_url(rel)
                  thumb_url = build_url(thumb_rel) if thumb_rel else url
                  item = {
                      "full_url": url,
                      "full_thumb_url": thumb_url,
                      "display_name": display_name(f),
                      "width": w, "height": h, "size": sz,
                  }
                  if ext in VIDEO_EXT:
                      item["type"] = 2
                      s3_url = build_s3_url(rel)
                      if s3_url:
                          item["stream_url"] = s3_url
                  items.append(item)
              out = os.path.join(root, cat["output"])
              os.makedirs(os.path.dirname(out), exist_ok=True)
              with open(out, "w", encoding="utf-8") as fh:
                  json.dump({"data": {"items": items, "total": len(items)}}, fh, ensure_ascii=False, indent=2)
              print(f"  -> {cat['output']} ({len(items)} items)")
              return seen

          root = sys.argv[1]
          cache = load_cache(root)
          all_seen = set()
          for c in CATEGORIES:
              print(f"\n[{c['dir']}]")
              all_seen |= generate(root, c, cache)

          stale = [k for k in cache if k not in all_seen]
          for k in stale:
              thumb = cache[k].get("thumb")
              if thumb:
                  tp = os.path.join(root, thumb)
                  if os.path.isfile(tp):
                      os.remove(tp)
                      print(f"    [thumb] removed {thumb}")
              del cache[k]
          if stale:
              print(f"\n[cache] pruned {len(stale)} stale entries")

          save_cache(root, cache)
          print(f"\n[cache] {len(cache)} entries saved")
          PYEOF
          python3 /tmp/gen_api.py mirror

      - name: Push changes to CNB
        run: |
          cd mirror
          git config user.name "r2-sync-bot"
          git config user.email "sync@deepalhome.com"
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to sync"
          else
            git commit -m "sync: $(TZ='Asia/Shanghai' date '+%Y-%m-%d %H:%M:%S CST')"
            git pull --rebase origin main
            git push
          fi
